// KX_ReflectionDumper_FindBytes.java
// @category KX
//
// Finds ArenaNet style class initializer structs by scanning executable memory
// using Memory.findBytes with a wildcard mask, then dumps them to a C++ header.
//
// Notes:
// - Scans for all LEA r?, [RIP+disp32] variants: 48 8D xx ?? ?? ?? ??
//   where xx in {05,0D,15,1D,25,2D,35,3D}.
// - Resolves the RIP target at hit + 7, runs a plausibility check,
//   then emits class layouts from each initializer.
//
// If you want to also try MOV RIP relative loads, set SEARCH_MOV_RIP to true.

import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.*;
import ghidra.program.model.mem.*;
import ghidra.program.model.symbol.*;
import ghidra.util.exception.*;
import ghidra.util.task.TaskMonitor;

import java.io.*;
import java.util.*;
import java.util.regex.Pattern;

public class KX_ReflectionDumper_FindBytes extends GhidraScript {

    // Config
    private static final boolean DEBUG = false;
    private static final boolean SEARCH_MOV_RIP = false; // set true if LEA yields no hits
    private static final int MAX_CLASSES = 20000;
    private static final int MAX_MEMBERS_PER_CLASS = 4096;

    // Type helpers
    private static final Pattern IDENT_OK_RE = Pattern.compile("^[A-Za-z_][A-Za-z0-9_]*$");
    private static final Pattern TYPE_SAFE_CHARS_RE = Pattern.compile("^[A-Za-z0-9_:\\*\\&\\[\\]<> ]+$");
    private static final Pattern ARTIFACT_TOKEN_RE = Pattern.compile("^[a-z]{1,3}[0-9a-f]{1,4}B$", Pattern.CASE_INSENSITIVE);

    private static final Set<String> PRIMITIVE_TYPES = new HashSet<>(Arrays.asList(
        "bool","char","signed char","unsigned char",
        "short","unsigned short",
        "int","unsigned int",
        "long","unsigned long",
        "long long","unsigned long long",
        "float","double","long double",
        "void","void*"
    ));
    private static final Set<String> QUALIFIERS = new HashSet<>(Arrays.asList("const","volatile"));
    private static final String[] ALLOWED_PREFIXES = new String[]{
        "hk","hkp","hkx","hka","hkcd","hkai","hkRef","hkArray","hkString","std"
    };

    private static final Map<Long,String> TAG_ID_TO_CPP = new HashMap<Long,String>() {{
        put(0x1L, "bool");
        put(0x2L, "short");
        put(0x3L, "int");
        put(0x4L, "float");
        put(0x5L, "long long");
        put(0x6L, "double");
        put(0x7L, "void*");
    }};

    @Override
    protected void run() throws Exception {
        if (!is64Bit()) {
            println("[KX] Program is not 64 bit, RIP relative patterns will not match");
            return;
        }

        File outFile = askFile("Select Output File", "Save Dump");
        if (outFile == null) return;

        List<Address> initializers = findInitializersByFindBytes();
        if (initializers.isEmpty() && SEARCH_MOV_RIP) {
            println("[KX] No LEA hits, trying MOV RIP relative patterns");
            initializers = findInitializersByFindBytes_MOV();
        }

        int classes = 0, members = 0;
        try (BufferedWriter w = new BufferedWriter(new FileWriter(outFile))) {
            // Header
            w.write("#pragma once\n\n");
            w.write("// This file was generated by a script. Do not edit.\n\n");
            w.write("//----------------------------------------------------\n");
            w.write("// Dumped by the KX Reflection Dumper\n");
            w.write("//----------------------------------------------------\n\n");
            w.flush();

            int limit = Math.min(initializers.size(), MAX_CLASSES);
            for (int i = 0; i < limit; i++) {
                Address a = initializers.get(i);
                int[] res = dumpOneInitializer(a, w);
                if (res[0] > 0) {
                    classes += 1;
                    members += res[1];
                }
                if (monitor.isCancelled()) break;
            }

            // Summary
            String summary = "--- Dump Finished ---\n"
                    + "Successfully dumped " + classes + " classes and " + members + " members.\n"
                    + "Output saved to: " + outFile.getAbsolutePath() + "\n";
            w.write("\n// --- Summary ---\n");
            for (String line : summary.split("\n")) {
                w.write("// " + line + "\n");
            }
            w.flush();

            println(summary);
        }
    }

    // Pattern scan for LEA r?, [RIP+disp32]
    private List<Address> findInitializersByFindBytes() throws MemoryAccessException {
        Memory mem = currentProgram.getMemory();
        List<Address> rawHits = new ArrayList<>();

        int[] modrms = new int[]{0x05,0x0D,0x15,0x1D,0x25,0x2D,0x35,0x3D};
        for (MemoryBlock blk : mem.getBlocks()) {
            if (!(blk.isInitialized() && blk.isLoaded() && blk.isExecute())) continue;
            Address start = blk.getStart();
            Address end = blk.getEnd();
            for (int m : modrms) {
                byte[] value = new byte[]{(byte)0x48, (byte)0x8D, (byte)m, 0,0,0,0};
                byte[] mask  = new byte[]{(byte)0xFF,(byte)0xFF,(byte)0xFF,0,0,0,0};
                Address addr = mem.findBytes(start, end, value, mask, true, monitor);
                while (addr != null) {
                    rawHits.add(addr);
                    Address next = addr.add(1);
                    addr = mem.findBytes(next, end, value, mask, true, monitor);
                }
            }
        }

        List<Address> out = new ArrayList<>();
        Set<Address> seen = new HashSet<>();
        for (Address h : rawHits) {
            Address tgt = resolveRipTargetFromLea(h);
            if (tgt == null) continue;
            if (seen.contains(tgt)) continue;
            if (looksPlausibleInitializer(tgt)) {
                seen.add(tgt);
                out.add(tgt);
            }
        }
        println("[KX] findBytes validated initializers: " + out.size());
        return out;
    }

    // Optional MOV r?, [RIP+disp32] scan if needed
    private List<Address> findInitializersByFindBytes_MOV() throws MemoryAccessException {
        Memory mem = currentProgram.getMemory();
        List<Address> rawHits = new ArrayList<>();

        int[] modrms = new int[]{0x05,0x0D,0x15,0x1D,0x25,0x2D,0x35,0x3D};
        for (MemoryBlock blk : mem.getBlocks()) {
            if (!(blk.isInitialized() && blk.isLoaded() && blk.isExecute())) continue;
            Address start = blk.getStart();
            Address end = blk.getEnd();
            for (int m : modrms) {
                byte[] value = new byte[]{(byte)0x48, (byte)0x8B, (byte)m, 0,0,0,0};
                byte[] mask  = new byte[]{(byte)0xFF,(byte)0xFF,(byte)0xFF,0,0,0,0};
                Address addr = mem.findBytes(start, end, value, mask, true, monitor);
                while (addr != null) {
                    rawHits.add(addr);
                    Address next = addr.add(1);
                    addr = mem.findBytes(next, end, value, mask, true, monitor);
                }
            }
        }

        List<Address> out = new ArrayList<>();
        Set<Address> seen = new HashSet<>();
        for (Address h : rawHits) {
            Address tgt = resolveRipTargetGeneric(h, 7); // same displacement layout
            if (tgt == null) continue;
            if (seen.contains(tgt)) continue;
            if (looksPlausibleInitializer(tgt)) {
                seen.add(tgt);
                out.add(tgt);
            }
        }
        println("[KX] MOV findBytes validated initializers: " + out.size());
        return out;
    }

    private Address resolveRipTargetFromLea(Address hit) {
        try {
            byte[] b = new byte[7];
            currentProgram.getMemory().getBytes(hit, b);
            if ((b[0] & 0xFF) != 0x48 || (b[1] & 0xFF) != 0x8D) return null;
            int disp = ((b[3] & 0xFF)) | ((b[4] & 0xFF) << 8) | ((b[5] & 0xFF) << 16) | ((b[6] & 0xFF) << 24);
            if ((disp & 0x80000000) != 0) disp -= 0x100000000L;
            long nextIp = hit.add(7).getOffset();
            long target = nextIp + disp;
            return toAddr(target);
        } catch (Exception e) {
            return null;
        }
    }

    private Address resolveRipTargetGeneric(Address hit, int insnLen) {
        try {
            byte[] b = new byte[insnLen];
            currentProgram.getMemory().getBytes(hit, b);
            int disp = ((b[3] & 0xFF)) | ((b[4] & 0xFF) << 8) | ((b[5] & 0xFF) << 16) | ((b[6] & 0xFF) << 24);
            if ((disp & 0x80000000) != 0) disp -= 0x100000000L;
            long nextIp = hit.add(insnLen).getOffset();
            long target = nextIp + disp;
            return toAddr(target);
        } catch (Exception e) {
            return null;
        }
    }

    // Plausibility check similar to your Python version
    private boolean looksPlausibleInitializer(Address a) {
        try {
            Memory mem = currentProgram.getMemory();
            long classNamePtr = mem.getLong(a) & 0xFFFFFFFFFFFFFFFFL;
            long memberListPtr = mem.getLong(a.add(0x18)) & 0xFFFFFFFFFFFFFFFFL;
            long numMembers = mem.getInt(a.add(0x20)) & 0xFFFFFFFFL;

            if (classNamePtr == 0 || numMembers == 0) return false;
            if (numMembers > MAX_MEMBERS_PER_CLASS) return false;
            if (!isValidReadPtr(classNamePtr)) return false;

            String name = readCString(classNamePtr, 128);
            if (name == null || name.equals("READ_ERROR") || name.equals("EMPTY")) return false;
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    // Dump one class, return [1 if dumped else 0, memberCount]
    private int[] dumpOneInitializer(Address base, BufferedWriter w) {
        try {
            Memory mem = currentProgram.getMemory();

            long classNamePtr  = mem.getLong(base.add(0x00)) & 0xFFFFFFFFFFFFFFFFL;
            long parentNamePtr = mem.getLong(base.add(0x08)) & 0xFFFFFFFFFFFFFFFFL;
            long memberListPtr = mem.getLong(base.add(0x18)) & 0xFFFFFFFFFFFFFFFFL;
            long numMembers    = mem.getInt(base.add(0x20)) & 0xFFFFFFFFL;

            String classNameRaw = readCString(classNamePtr, 128);
            if (!isAsciiLike(classNameRaw)) classNameRaw = String.format("Class_0x%X", classNamePtr);
            String className = sanitizeCppIdentifier(classNameRaw, String.format("Class_0x%X", classNamePtr));

            String parentRaw = readCString(parentNamePtr, 128);
            if (!isAsciiLike(parentRaw) || parentRaw.equals(classNameRaw)) parentRaw = null;
            String parentName = parentRaw != null ? sanitizeCppIdentifier(parentRaw, "Base") : null;

            w.write("//----------------------------------------------------\n");
            w.write(String.format("// Class: %s (Initializer @ %s)\n", className, base.toString()));
            if (parentName != null) {
                w.write(String.format("struct %s : public %s {\n", className, parentName));
            } else {
                w.write(String.format("struct %s {\n", className));
            }

            int memberCount = 0;
            if (numMembers > 0 && isValidReadPtr(memberListPtr)) {
                Address mbase = toAddr(memberListPtr);
                int stride = 0x18;
                int safeN = (int)Math.min(numMembers, MAX_MEMBERS_PER_CLASS);
                for (int i = 0; i < safeN; i++) {
                    try {
                        Address e = mbase.add((long)i * stride);
                        long sigOrType = mem.getLong(e.add(0x00)) & 0xFFFFFFFFFFFFFFFFL;
                        long namePtr   = mem.getLong(e.add(0x08)) & 0xFFFFFFFFFFFFFFFFL;
                        long tdata     = mem.getLong(e.add(0x10)) & 0xFFFFFFFFFFFFFFFFL;
                        int fieldOff = (int)(tdata & 0xFFFF);
                        int flags    = (int)((tdata >> 16) & 0xFFFF);

                        String fnameRaw = readCString(namePtr, 128);
                        if (!isAsciiLike(fnameRaw)) fnameRaw = null;
                        if (fnameRaw != null && ARTIFACT_TOKEN_RE.matcher(fnameRaw).matches()) fnameRaw = null;
                        String safeField = sanitizeCppIdentifier(
                            fnameRaw, String.format("member_0x%X", namePtr));

                        String typeNameRaw = describeType(sigOrType, tdata);
                        String safeType = sanitizeCppTypeName(typeNameRaw, "unknown_t");
                        if (ARTIFACT_TOKEN_RE.matcher(safeType).matches()) safeType = "unknown_t";

                        w.write(String.format("    /* 0x%04X */ %-40s %s; // Flags: 0x%04X\n",
                                fieldOff, safeType, safeField, flags));
                        memberCount++;
                    } catch (MemoryAccessException ex) {
                        w.write(String.format("    // Read error in member list at entry %d\n", i));
                        break;
                    } catch (Exception ex) {
                        w.write(String.format("    // Exception at entry %d: %s\n", i, ex.toString()));
                        break;
                    }
                }
            }
            w.write("};\n\n");
            w.flush();
            return new int[]{1, memberCount};
        } catch (Exception e) {
            try {
                w.write(String.format("// Skip at %s: %s\n", base.toString(), e.toString()));
            } catch (IOException ignored) {}
            return new int[]{0, 0};
        }
    }

    // Utilities

    private boolean is64Bit() {
        return currentProgram.getAddressFactory().getDefaultAddressSpace().getSize() == 64;
    }

    private boolean isValidReadPtr(long p) {
        try {
            Address a = toAddr(p);
            MemoryBlock blk = getMemoryBlock(a);
            return blk != null && blk.isInitialized() && blk.isRead();
        } catch (Exception e) {
            return false;
        }
    }

    private String readCString(long addr, int limit) {
        if (!isValidReadPtr(addr)) return null;
        try {
            Address a = toAddr(addr);
            Memory mem = currentProgram.getMemory();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < limit; i++) {
                byte b = mem.getByte(a);
                if (b == 0) break;
                int v = b & 0xFF;
                if (v >= 32 && v <= 126) {
                    sb.append((char)v);
                } else {
                    break;
                }
                a = a.add(1);
            }
            if (sb.length() == 0) return "EMPTY";
            return sb.toString();
        } catch (Exception e) {
            return "READ_ERROR";
        }
    }

    private boolean isAsciiLike(String s) {
        if (s == null || s.equals("EMPTY") || s.equals("READ_ERROR")) return false;
        if (s.length() > 128) return false;
        for (int i = 0; i < s.length(); i++) {
            int c = s.charAt(i);
            if (c < 32 || c > 126) return false;
        }
        return true;
    }

    private String sanitizeCppIdentifier(String name, String fallback) {
        if (name == null || name.isEmpty()) return fallback;
        String clean = name.replaceAll("[^A-Za-z0-9_]", "_").replaceAll("_+", "_");
        clean = trimUnderscores(clean);
        if (clean.isEmpty()) return fallback;
        if (Character.isDigit(clean.charAt(0))) clean = "_" + clean;
        if (!IDENT_OK_RE.matcher(clean).matches()) return fallback;
        return clean.length() > 128 ? clean.substring(0,128) : clean;
    }

    private String trimUnderscores(String s) {
        int i = 0, j = s.length() - 1;
        while (i <= j && s.charAt(i) == '_') i++;
        while (j >= i && s.charAt(j) == '_') j--;
        return i > j ? "" : s.substring(i, j + 1);
    }

    private boolean isValidTypeIdentToken(String tok) {
        if (PRIMITIVE_TYPES.contains(tok) || QUALIFIERS.contains(tok)) return true;
        if (!IDENT_OK_RE.matcher(tok).matches()) return false;
        if (tok.length() < 2) return false;
        if (Character.isUpperCase(tok.charAt(0))) return true;
        for (String pref : ALLOWED_PREFIXES) {
            if (tok.startsWith(pref)) return true;
        }
        return false;
    }

    private boolean isPlausibleTypeString(String s) {
        if (s == null || s.equals("EMPTY") || s.equals("READ_ERROR")) return false;
        s = s.trim();
        if (PRIMITIVE_TYPES.contains(s)) return true;
        if (!TYPE_SAFE_CHARS_RE.matcher(s).matches()) return false;
        boolean hasAlpha = false;
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (Character.isLetter(ch)) { hasAlpha = true; break; }
        }
        return hasAlpha;
    }

    private String sanitizeCppTypeName(String name, String fallback) {
        if (name == null || name.isEmpty()) return fallback;
        String s = name.trim().replaceAll("\\s+", " ");
        if (PRIMITIVE_TYPES.contains(s)) return s;
        if (!isPlausibleTypeString(s)) return fallback;

        // tokenize by separators while keeping them
        List<String> out = new ArrayList<>();
        StringBuilder cur = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (" :<>,[]".indexOf(ch) >= 0) {
                if (cur.length() > 0) {
                    String tok = cur.toString();
                    if (!isValidTypeIdentToken(tok)) return fallback;
                    out.add(tok);
                    cur.setLength(0);
                }
                out.add(String.valueOf(ch));
            } else if (ch == '*' || ch == '&') {
                if (cur.length() > 0) {
                    String tok = cur.toString();
                    if (!isValidTypeIdentToken(tok)) return fallback;
                    out.add(tok);
                    cur.setLength(0);
                }
                out.add(String.valueOf(ch));
            } else {
                cur.append(ch);
            }
        }
        if (cur.length() > 0) {
            String tok = cur.toString();
            if (!isValidTypeIdentToken(tok)) return fallback;
            out.add(tok);
        }
        StringBuilder sb = new StringBuilder();
        for (String t : out) sb.append(t);
        String result = sb.toString().trim();
        if (result.isEmpty() || ARTIFACT_TOKEN_RE.matcher(result).matches()) return fallback;
        return result;
        }

    private String describeType(long signatureOrTypeVal, long typeDataOrOffset) {
        if (signatureOrTypeVal == 0) return "unknown_t";
        // try as c string pointer
        String typeStr = readCString(signatureOrTypeVal, 128);
        if (typeStr != null && !typeStr.equals("READ_ERROR") && !typeStr.equals("EMPTY")) {
            String safe = sanitizeCppTypeName(typeStr, null);
            if (safe != null) return safe;
        }
        if (TAG_ID_TO_CPP.containsKey(signatureOrTypeVal)) return TAG_ID_TO_CPP.get(signatureOrTypeVal);
        return String.format("TypeTag_0x%X", signatureOrTypeVal);
    }
}
