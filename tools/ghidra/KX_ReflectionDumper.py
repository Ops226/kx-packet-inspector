# KX_ReflectionDumper.py
# Ghidra Jython Script to dump ArenaNet's custom reflection system to a file.
# Final version based on the user's successful forensic analysis.

from ghidra.program.model.address import Address
import os

# --- Helper Functions ---

def is_valid_read_ptr(p):
    """Checks if a long integer is a plausible pointer in the program's memory space."""
    if p is None or p == 0:
        return False
    try:
        blk = getMemoryBlock(toAddr(p))
        if blk is None or not blk.isInitialized() or not blk.isRead():
            return False
    except:
        return False
    return True

def read_c_string(p, limit=128):
    """Safely reads a C-style string from a given address."""
    if not is_valid_read_ptr(p):
        return "ID_0x%X" % (p & 0xFFFFFFFFFFFFFFFF)
    s = []
    a = toAddr(p)
    try:
        for _ in range(limit):
            b = getByte(a) & 0xFF
            if b == 0:
                break
            if 32 <= b <= 126: # Printable ASCII
                s.append(chr(b))
            else:
                break
            a = a.add(1)
    except:
        return "READ_ERROR"
    return "".join(s) if s else "EMPTY"

def u64(addr):
    return getLong(addr) & 0xFFFFFFFFFFFFFFFF

def u32(addr):
    return getInt(addr) & 0xFFFFFFFF

# --- Main Dumper Logic ---

def dump_class_layouts(start_ptr, end_ptr, output_file):
    cur = toAddr(start_ptr)
    end = toAddr(end_ptr)

    class_stride = 0x28  # 40 bytes (Confirmed)
    member_stride = 0x18 # 24 bytes (Confirmed)

    class_count = 0
    member_count = 0

    output_file.write("--- ArenaNet Custom Reflection Dump ---\n")
    output_file.write("// Generated by KX_ReflectionDumper.py\n")

    while cur < end and not monitor.isCancelled():
        # Read the ClassInitializer structure
        class_name_ptr  = u64(cur.add(0x00))
        parent_name_ptr = u64(cur.add(0x08))
        member_list_ptr = u64(cur.add(0x18))
        num_members     = u32(cur.add(0x20))

        class_name  = read_c_string(class_name_ptr)
        parent_name = read_c_string(parent_name_ptr)

        output_file.write("\n//----------------------------------------------------\n")
        output_file.write("// Class: {}\n".format(class_name))
        output_file.write("// Parent: {}\n".format(parent_name))
        output_file.write("// Found at Initializer: {}\n".format(cur))
        output_file.write("//----------------------------------------------------\n")
        output_file.write("struct {} : public {} {{\n".format(class_name, parent_name))

        if num_members > 0 and is_valid_read_ptr(member_list_ptr):
            mbase = toAddr(member_list_ptr)
            for i in range(num_members):
                entry_addr = mbase.add(i * member_stride)

                # Read the MemberInitializer (qword, qword, dword, dword layout)
                tag_or_type_ptr = u64(entry_addr.add(0x00))
                name_ptr_or_flags = u64(entry_addr.add(0x08))
                field_offset      = u32(entry_addr.add(0x10))
                type_data         = u32(entry_addr.add(0x14))
                
                # Heuristic to describe the type tag
                if tag_or_type_ptr < 0x1000:
                    type_desc = "Tag={}".format(tag_or_type_ptr)
                else:
                    type_desc = "TypeName='{}'".format(read_c_string(tag_or_type_ptr))

                field_name = read_c_string(name_ptr_or_flags)

                output_file.write("    // Member[{}]: Name='{}' | {} | Offset=0x{:04X} | TypeData=0x{:X}\n".format(
                      i, field_name, type_desc, field_offset, type_data))
                member_count += 1

        output_file.write("}};\n")
        
        class_count += 1
        cur = cur.add(class_stride)
    
    return class_count, member_count

# --- Script Entry Point ---

if __name__ == "__main__":
    try:
        # Prompt user to select a file for saving the output
        output_file_path = askFile("Select Output File", "Save Dump").getAbsolutePath()

        if output_file_path:
            with open(output_file_path, "w") as f:
                
                # Configure the known memory ranges for the ClassInitializer arrays
                # You can add more ranges here if you find them
                initializer_blocks = [
                    (0x142607840, 0x14260BC60),
                ]
                
                total_classes = 0
                total_members = 0

                for start_addr, end_addr in initializer_blocks:
                    classes, members = dump_class_layouts(start_addr, end_addr, f)
                    total_classes += classes
                    total_members += members
                
                summary_message = "--- Dump Finished ---\n"
                summary_message += "Successfully dumped {} classes and {} members.\n".format(total_classes, total_members)
                summary_message += "Output saved to: {}".format(output_file_path)
                
                f.write("\n" + summary_message)
                print(summary_message)

    except Exception as e:
        print("An error occurred: {}".format(e))