# Dumps ArenaNet's custom reflection system to a C++ header file.
# Part of the kx-packet-inspector project.
#
# This script is the final version based on a successful forensic analysis
# of the engine's type decoder virtual machine.
#
# Licensed under the same terms as the kx-packet-inspector project:
# https://github.com/kxtools/kx-packet-inspector
#
# MIT License
#
# @category KX

from ghidra.program.model.address import Address
import os

# --- Helper Functions ---

def is_valid_read_ptr(p):
    """Checks if a long integer is a plausible pointer in the program's memory space."""
    if p is None or p == 0:
        return False
    try:
        blk = getMemoryBlock(toAddr(p))
        if blk is None or not blk.isInitialized() or not blk.isRead():
            return False
    except:
        return False
    return True

def read_c_string(p, limit=128):
    """Safely reads a C-style string from a given address."""
    if not is_valid_read_ptr(p):
        return None  # Return None for invalid pointers
    s = []
    a = toAddr(p)
    try:
        for _ in range(limit):
            b = getByte(a) & 0xFF
            if b == 0:
                break
            if 32 <= b <= 126:  # Printable ASCII
                s.append(chr(b))
            else:
                # Stop at the first non-printable character
                break
            a = a.add(1)
    except:
        return "READ_ERROR"
    return "".join(s) if s else "EMPTY"

def u64(addr):
    return getLong(addr) & 0xFFFFFFFFFFFFFFFF

def u32(addr):
    return getInt(addr) & 0xFFFFFFFF

# --- Type Decoding Logic ---

# Educated guess for common Tag IDs to C++ type mapping.
# These are based on the sizes observed in Reflect_GenericCopyDispatcher and Reflect_MemmoveDispatcher.
TAG_ID_TO_CPP_TYPE_MAP = {
    0x1: "bool",        # 1-byte operations
    0x2: "short",       # 2-byte operations
    0x3: "int",         # 4-byte operations
    0x4: "float",       # 4-byte operations
    0x5: "long long",   # 8-byte operations
    0x6: "double",      # 8-byte operations
    0x7: "void*",       # 8-byte operations (generic pointer)
    # Add more as discovered from the actual Type Decoder VM switch.
}

def decode_type_data(type_data_val):
    """
    Decodes the typeDataOrOffset field from the MemberInitializer.
    Based on forensic analysis, this is a bitfield.
    """
    offset = type_data_val & 0xFFFF
    flags = (type_data_val >> 16) & 0xFFFF
    return offset, flags

def describe_type(signature_or_type_val):
    """
    Creates a human-readable description of a member's type.
    Attempts to infer C++ types based on common Tag IDs and by reading strings.
    """
    # 1) Try to read as a C-string
    type_str = read_c_string(signature_or_type_val)
    if type_str and type_str != "READ_ERROR" and type_str != "EMPTY":
        return type_str

    # 2) If not a string, check known primitive type IDs
    if signature_or_type_val in TAG_ID_TO_CPP_TYPE_MAP:
        return TAG_ID_TO_CPP_TYPE_MAP[signature_or_type_val]

    # 3) Fallback
    return "TypeTag_0x{:X}".format(signature_or_type_val)

# --- Main Dumper Logic ---

def dump_class_layouts(start_ptr, end_ptr, output_file):
    cur = toAddr(start_ptr)
    end = toAddr(end_ptr)

    class_stride = 0x28  # 40 bytes (confirmed)
    member_stride = 0x18 # 24 bytes (confirmed)

    class_count = 0
    member_count = 0

    output_file.write("//----------------------------------------------------\n")
    output_file.write("// Dumped by the KX Reflection Dumper\n")
    output_file.write("// Part of the kx-packet-inspector project\n")
    output_file.write("//----------------------------------------------------\n\n")
    output_file.write("// --- ArenaNet Custom hkReflect Dump ---\n")
    output_file.write("// Generated by KX_ReflectionDumper.py (Final Version)\n")
    output_file.write("// Analysis based on reversing the engine's Type Decoder VM.\n\n")

    while cur < end and not monitor.isCancelled():
        # Read the ClassInitializer structure
        class_name_ptr  = u64(cur.add(0x00))
        parent_name_ptr = u64(cur.add(0x08))
        member_list_ptr = u64(cur.add(0x18))
        num_members     = u32(cur.add(0x20))

        class_name = read_c_string(class_name_ptr)
        if not class_name:
            class_name = "Class_0x{:X}".format(class_name_ptr)

        parent_name = read_c_string(parent_name_ptr)
        # Prevent self-inheritance in output
        if not parent_name or parent_name == class_name:
            parent_name = None

        output_file.write("//----------------------------------------------------\n")
        output_file.write("// Class: {} (Initializer @ {})\n".format(class_name, cur))

        if parent_name:
            output_file.write("struct {} : public {} {{\n".format(class_name, parent_name))
        else:
            output_file.write("struct {} {{\n".format(class_name))

        if num_members > 0 and is_valid_read_ptr(member_list_ptr):
            mbase = toAddr(member_list_ptr)
            for i in range(num_members):
                entry_addr = mbase.add(i * member_stride)

                # Read the MemberInitializer (FieldDecl) structure
                signature_or_type_ptr = u64(entry_addr.add(0x00))
                name_ptr              = u64(entry_addr.add(0x08))
                type_data_or_offset   = u64(entry_addr.add(0x10))

                field_name = read_c_string(name_ptr)
                if not field_name:
                    field_name = "member_0x{:X}".format(name_ptr)

                field_offset, type_flags = decode_type_data(type_data_or_offset)
                type_name = describe_type(signature_or_type_ptr)

                # Write the C++ style member definition
                output_file.write("    /* 0x{:04X} */ {:<40} {}; // Flags: 0x{:04X}\n".format(
                    field_offset, type_name, field_name, type_flags))

                member_count += 1

        output_file.write("};\n\n")

        class_count += 1
        cur = cur.add(class_stride)

    return class_count, member_count

# --- Script Entry Point ---

if __name__ == "__main__":
    try:
        output_file_path = askFile("Select Output File", "Save Dump").getAbsolutePath()

        if output_file_path:
            with open(output_file_path, "w") as f:
                initializer_blocks = [
                    (0x142607840, 0x14260BC60),
                ]

                total_classes = 0
                total_members = 0

                f.write("#pragma once\n\n")
                f.write("// This file was generated by a script. Do not edit.\n\n")

                for start_addr, end_addr in initializer_blocks:
                    f.write("// Dumping block: 0x{:X} - 0x{:X}\n".format(start_addr, end_addr))
                    classes, members = dump_class_layouts(start_addr, end_addr, f)
                    total_classes += classes
                    total_members += members

                summary_message = "--- Dump Finished ---\n"
                summary_message += "Successfully dumped {} classes and {} members.\n".format(total_classes, total_members)
                summary_message += "Output saved to: {}\n".format(output_file_path)

                f.write("\n// --- Summary ---\n")
                f.write("// " + summary_message.replace("\n", "\n// "))

                print(summary_message)

    except Exception as e:
        import traceback
        print("An error occurred:")
        traceback.print_exc()
