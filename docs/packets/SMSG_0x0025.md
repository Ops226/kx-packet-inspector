# SMSG_0x0025 — Structured Update (Multiple Variants)

Direction: Server → Client  
Observed sizes: 6, 31, 36, 56 bytes  
Endianness: Little endian

## Summary

SMSG_0x0025 appears in several small, structured variants that look like typed updates with compact payloads. Based on repeated shapes in the provided logs, we document conservative layouts to enable safe parsing now. Exact handler mapping via the SrvMsgDispatcher selector (+0x18) is pending.

## Observed Variants and Minimal Layouts

We present minimal, conservative field cuts. Names are placeholders where semantics are not yet confirmed.

### Variant A — Size = 6

Examples:
- `02 04 02 00 00 00`
- `02 04 01 00 00 00`

Proposed layout:

Offset | Type | Name      | Notes
------ | ---- | --------- | -----
0x00   | u8   | type      | Observed 0x02
0x01   | u8   | subtype   | Observed 0x04
0x02   | u16  | value     | 0x0001 or 0x0002 in samples
0x04   | u16  | zero      | Observed 0x0000

Notes:
- Tight, flag-like update with a small u16 payload and trailing zero for alignment/reserved.

---

### Variant B — Size = 31

Examples:
- `FF 03 02 00 00 00 59 26 00 00 01 00 00 00 9B 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 02`
- `FF 03 01 00 00 00 D5 57 00 00 02 00 00 00 9B 00 00 00 FF FF FF FF 00 00 00 00 00 00 00 00 02`

Proposed layout (minimal, packed):

Offset | Type  | Name        | Notes
------ | ----- | ----------- | -----
0x00   | u8    | hdr0        | Observed 0xFF
0x01   | u8    | hdr1        | Observed 0x03
0x02   | u16   | entry_id    | 0x0002 or 0x0001 in examples
0x04   | u32   | field_a     | e.g., 0x00002659, 0x000057D5
0x08   | u32   | count_or_ix | small values: 1 or 2
0x0C   | u16   | const_9b    | Observed 0x009B
0x0E   | u16   | zero16      | Observed 0x0000
0x10   | u32   | sentinel_ff | Observed 0xFFFFFFFF
0x14   | u32   | zeros_0     | Observed 0x00000000
0x18   | u32   | zeros_1     | Observed 0x00000000
0x1C   | u8    | tail_code   | Observed 0x02

Notes:
- Final length is 31 bytes; the tail 0x02 likely denotes a small code/state.
- The 0xFF 0x03 header pair suggests a fixed class/subclass.

---

### Variant C — Size = 36

Examples:
- `01 04 01 00 00 00 9B 00 00 00 2C 74 00 00 A9 18 00 00 FF 77 92 45 1F AE FB 44 8F 09 95 C4 00 00 00 00 00 06`
- `01 04 02 00 00 00 9B 00 00 00 2C 74 00 00 A9 18 00 00 FF 77 92 45 1F AE FB 44 8F 09 95 C4 00 00 00 00 00 06`

Proposed layout:

Offset | Type  | Name         | Notes
------ | ----- | ------------ | -----
0x00   | u8    | type         | Observed 0x01
0x01   | u8    | subtype      | Observed 0x04
0x02   | u16   | entry_id     | 0x0001 or 0x0002
0x04   | u32   | zero32       | 0x00000000
0x08   | u16   | const_9b     | 0x009B
0x0A   | u16   | zero16       | 0x0000
0x0C   | u32   | field_b      | e.g., 0x0000742C
0x10   | u32   | field_c      | e.g., 0x000018A9
0x14   | u32   | f0           | e.g., 0x459277FF (float-like)
0x18   | u32   | f1           | e.g., 0x44FBAE1F (float-like)
0x1C   | u32   | f2           | e.g., 0xC495098F (float-like)
0x20   | u24   | zeros_tail   | 3 bytes of 0x00 observed
0x23   | u8    | tail_code    | Observed 0x06

Notes:
- The 3 consecutive u32s at 0x14, 0x18, 0x1C look like packed floats (XYZ or color/tint).
- Tail 0x06 appears stable; may be a sub-op marker.

---

### Variant D — Size = 56

Examples:
- `04 04 01 00 00 00 02 00 00 00 00 00 00 00 00 6A E9 78 45 FD D9 20 45 8F 09 95 C4 00 00 00 00 00 00 E1 44 00 41 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00`
- `04 04 02 00 00 00 08 00 00 00 00 00 00 00 00 6A E9 78 45 FD D9 20 45 8F 09 95 C4 00 00 00 00 00 00 48 43 00 41 00 00 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00`

Proposed layout:

Offset | Type  | Name           | Notes
------ | ----- | -------------- | -----
0x00   | u8    | type           | 0x04
0x01   | u8    | subtype        | 0x04
0x02   | u16   | entry_id       | 0x0001 or 0x0002
0x04   | u32   | zero32         | 0x00000000
0x08   | u32   | count_or_size  | e.g., 0x00000002 / 0x00000008
0x0C   | u32   | zero32_b       | 0x00000000
0x10   | u32   | zero32_c       | 0x00000000
0x14   | u32   | f0             | e.g., 0x4578E96A (float-like)
0x18   | u32   | f1             | e.g., 0x4520D9FD (float-like)
0x1C   | u32   | f2             | e.g., 0xC495098F (float-like)
0x20   | u32   | zero32_d       | 0x00000000
0x24   | u32   | zero32_e       | 0x00000000
0x28   | u32   | f3             | e.g., 0x44E10000 / 0x43480000 (float-like)
0x2C   | u16   | u16_a          | e.g., 0x4100
0x2E   | u16   | zero16         | 0x0000
0x30   | u32   | zero32_f       | 0x00000000
0x34   | u32   | zero32_g       | 0x00000000
0x38   | u32   | zero32_h       | 0x00000000
0x3C   | u16   | const_4        | 0x0004
0x3E   | u14   | zeros_tail     | Remaining zeros to 56 bytes
0x3F   | u8    | tail_code      | Appears 0x00 (overall padding/terminator)

Notes:
- Multiple zero blocks suggest alignment and reserved fields.
- f0..f3 look like positions/angles/scalars; 0x43480000 is 200.0f; 0x44E10000 is ~1800.5f, plausible for coordinates/scale.
- count_or_size at 0x08 varies (2, 8), likely content count or payload length.

## Behavior / Semantics (Hypotheses)

- 0x0025 seems to be a typed multi-variant message carrying short updates; large variants include float-like triples/quads (position/velocity/scalar attributes).
- Smaller variants (6, 31) look like control/indexed updates with sentinel bytes (e.g., 0xFF 0x03 header, tail 0x02/0x06).

## Mapping Status

- Handler mapping via SrvMsgDispatcher selector (+0x18) is pending. This page focuses on conservative on-wire decoding to unblock consumers.

## Proposed C-style structs (examples)

```cpp
#pragma pack(push, 1)

// Variant A (6 bytes)
struct smsg_0025_v6 {
    uint8_t  type;      // 0x02
    uint8_t  subtype;   // 0x04
    uint16_t value;     // e.g., 1 or 2
    uint16_t zero;      // 0x0000
};

// Variant B (31 bytes) - packed example with sentinels
struct smsg_0025_v31 {
    uint8_t  hdr0;        // 0xFF
    uint8_t  hdr1;        // 0x03
    uint16_t entry_id;    // 1 or 2
    uint32_t field_a;     // e.g., 0x00002659 / 0x000057D5
    uint32_t count_or_ix; // 1 or 2
    uint16_t const_9b;    // 0x009B
    uint16_t zero16;      // 0x0000
    uint32_t sentinel_ff; // 0xFFFFFFFF
    uint32_t zeros0;      // 0
    uint32_t zeros1;      // 0
    uint8_t  tail_code;   // 0x02
};

// Variant C (36 bytes) - float-like triple
struct smsg_0025_v36 {
    uint8_t  type;        // 0x01
    uint8_t  subtype;     // 0x04
    uint16_t entry_id;    // 1 or 2
    uint32_t zero32;      // 0
    uint16_t const_9b;    // 0x009B
    uint16_t zero16;      // 0
    uint32_t field_b;     // e.g., 0x0000742C
    uint32_t field_c;     // e.g., 0x000018A9
    float    f0;          // from u32
    float    f1;          // from u32
    float    f2;          // from u32
    uint8_t  zeros_tail[3];
    uint8_t  tail_code;   // 0x06
};

// Variant D (56 bytes) - extended with floats and counts
struct smsg_0025_v56 {
    uint8_t  type;          // 0x04
    uint8_t  subtype;       // 0x04
    uint16_t entry_id;      // 1 or 2
    uint32_t zero32;        // 0
    uint32_t count_or_size; // 2 or 8
    uint32_t zero32_b;      // 0
    uint32_t zero32_c;      // 0
    float    f0;            // from u32
    float    f1;            // from u32
    float    f2;            // from u32
    uint32_t zero32_d;      // 0
    uint32_t zero32_e;      // 0
    float    f3;            // from u32 (e.g., 200.0f or ~1800.xf)
    uint16_t u16_a;         // e.g., 0x4100
    uint16_t zero16;        // 0
    uint32_t zero32_f;      // 0
    uint32_t zero32_g;      // 0
    uint32_t zero32_h;      // 0
    uint16_t const_4;       // 0x0004
    uint8_t  zeros_tail[15];
};

#pragma pack(pop)
```

## Confidence

- Layout confidence: Medium-High (stable sizes and repeated field patterns).
- Semantics: Medium-Low (names are placeholders; float-like groups likely coordinates/scalars).
- Mapping: Pending. This page is intended to unblock parsing and further correlation now.
