# SMSG 0x0040 — String Notify (Channel 2)

Status: Confirmed structure.  
Schema symbol: `DAT_142511860`

## Summary

This message carries a null-terminated ANSI string that is dispatched through the game's message connection on channel 2.

## Dispatcher Path

Gs2c_PostParseDispatcher (case 0x40):

```
lVar16 = Msg_BuildArgs_FromSchema((short *)(param_1 + 0x170), &DAT_142511860, param_3[2], (ulonglong)(param_3 + 4));
local_60 = (longlong *)0x0;
uStack_58 = uStack_58 & 0xffffffff00000000;
pcVar4 = *(char **)(lVar16 + 2);
local_50 = CONCAT22(local_50._2_2_,1);
uVar6 = FUN_1409a8e80();
local_50 = CONCAT22((short)uVar6,(undefined2)local_50);
local_4c = 0;
ManagedString_Build_FromAnsiLen1(&local_60, pcVar4, (char *)0xffffffff, 0);
MsgConn_DispatchString(param_1, &local_60, 2, param_3[2], param_3 + 4);
```

Key observations:
- Only the pointer at `lVar16 + 0x02` is read; this is the ANSI text.
- The string is wrapped using `ManagedString_Build_FromAnsiLen1` (length = -1 → treat as null-terminated).
- Dispatched via `MsgConn_DispatchString` with `channel = 2`.

## Structure

The schema materialized by `Msg_BuildArgs_FromSchema` for this opcode is minimal. For this handler only the text pointer is used:

```c
// Transient schema tuple produced for opcode 0x0040
struct SMSG_STRING_NOTIFY {
    // 0x00: small header/flags/arg-count (not used in this path)
    // 0x02: ANSI string pointer
    const char* text;     // at +0x02
};
static_assert(offsetof(SMSG_STRING_NOTIFY, text) == 0x2, "text pointer is at +0x02");
```

Effective payload model on the wire: a single null-terminated ANSI string.

## Cross-References

- Raw decompilation:
  - `docs/raw_decompilations/Gs2c_PostParseDispatcher.c` (case 0x40)
  - `docs/raw_decompilations/ManagedString_Build_FromAnsiLen1.c`
  - `docs/raw_decompilations/Msg_BuildArgs_FromSchema.c`
- Related:
  - `docs/packets/SMSG_0x003F.md` — identical layout; different dispatch channel

## Notes

- 0x0040 and 0x003F share the same layout (ANSI string at +0x02); only the dispatch channel differs (2 vs 1).
- For higher-level modeling both can reuse the same struct with channel implied by opcode.
