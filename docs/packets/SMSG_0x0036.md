# SMSG 0x0036 — Immediate Event Queue Push

Status: Confirmed (code-backed)

Dispatch Path:
- Dispatcher: FUN_14025DA50, case 0x36 (index = opcode − 0x2B)
- Schema: &DAT_142513080 → passed to FUN_140FD4D50 (typed arg builder)
- Handler code slice (addresses approximate): 0x14025E1F7..0x14025E2F9

Behavior Summary:
- Parses tuple via FUN_140FD4D50(&DAT_142513080) → RBX.
- Resolves connection/global context: ctx = *(longlong*)(FUN_1409A4490() + 0x1F0).
- Performs a keyed lookup (e.g., under ctx->1D0) using tuple fields; if found, immediately enqueues an event into the context queue via:
  • FUN_140251290(&ctx->E8, &LAB_14025368C, &foundObj, (RBX + 0x0A))  // representative offsets
- Straight-line flow after tuple creation; no deep loops.

Key Instructions (evidence):
- tuple = FUN_140FD4D50(&DAT_142513080)
- ctx = *(longlong*)(FUN_1409A4490() + 0x1F0)
- obj = lookup using tuple material (pointer + u16* pair), typical of this block
- FUN_140251290(&ctx->E8, &LAB_14025368C, &obj, tuple + 0x0A)

Field Layout (inferred from handler offsets):
- +0x0A: payload/arguments passed to the queue callback
- Early tuple fields: key(s) used for object lookup (pointer + u16*)

Wire Structure (first-pass, based on schema usage)

```cpp
#pragma pack(push, 1)

struct Smsg_0036_Tuple {
    // Keys used to resolve obj in ctx (pointer + u16*; exact widths via &DAT_142513080)
    uint8_t   key_bytes[10];
    // Arguments passed to the queued callback
    uint8_t   callback_args[];  // starts at +0x0A
};

#pragma pack(pop)
```

Notes:
- Another “parse → lookup → enqueue” pattern with minimal branching, ideal for quick validation and structure extraction via schema typecodes.
