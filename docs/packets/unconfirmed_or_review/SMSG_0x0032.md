# SMSG 0x0032 — Forward with Extra Context

Status: Confirmed (code-backed)

Dispatch Path:
- Dispatcher: FUN_14025DA50, case 0x32 (index = opcode − 0x2B)
- Schema: &DAT_142511A70 → passed to FUN_140FD4D50 (typed arg builder)
- Handler code slice (addresses approximate): 0x14025DDF0..0x14025DEB8

Behavior Summary:
- Parses tuple via FUN_140FD4D50(&DAT_142511A70) → RBX.
- Forwards the tuple to FUN_14025F130(param_1, (RBX + 0x04), RBX, (RBX + 0x45)) – i.e., along with extra pointer/length context taken from the tuple.
- No additional branching beyond basic guards.

Key Instructions (evidence):
- tuple = FUN_140FD4D50(&DAT_142511A70)
- FUN_14025F130(param_1, tuple + 0x04, tuple, tuple + 0x45)

Field Layout (inferred from handler offsets):
- +0x04: context argument (likely pointer/handle used by the callee)
- +0x45: additional context (likely length/flags/pointer depending on BuildArgs)

Wire Structure (first-pass, from BuildArgs semantics + offsets used)

**Note:** Exact sizes for “context” members derive from the schema VM; adjust names as we refine.

- **Expected elements:**
  - Scalars: `u8`/`u16`/`u32` via `0x02`/`0x17`
  - Optional string/blob: `0x14` (len-u8) or `0x15` (len-u16)
  - Additional embedded pointer/length (seen at `+0x45`)

```cpp
#pragma pack(push, 1)

struct Smsg_0032_Tuple {
    // Leading key/context used by callee
    // Exact scalar composition determined by typecodes prior to +0x04
    uint8_t   key_bytes[4];   // up to offset 0x04
    uint8_t*  ctx_ptr_at_04;  // (tuple + 0x04) interpreted by FUN_14025F130
    // ...
    uint8_t   opaque_at_45[]; // (tuple + 0x45) extra context (len/flags/payload)
};

#pragma pack(pop)
```

Notes:
- Straight parse → forward with two extra tuple-derived context pointers. Good candidate for structure finalization by decoding the &DAT_142511A70 typecodes and cross-checking a few captures.
