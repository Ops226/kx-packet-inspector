# SMSG 0x0043 — Immediate Notification Enqueue

Status: Confirmed (code-backed)

Dispatch Path:
- Dispatcher: FUN_14025DA50, case 0x43 (index = opcode − 0x2B)
- Schema: &DAT_142513570 → passed to FUN_140FD4D50 (typed arg builder)
- Handler code slice (addresses approximate): 0x14025E640..0x14025E6A8

Behavior Summary:
- Parses tuple via FUN_140FD4D50(&DAT_142513570) → RBX.
- Resolves connection/global context: ctx = *(longlong*)(FUN_1409A4490() + 0x1F0).
- Immediately enqueues a notification/event into the context queue (ctx + 0x88) using a fixed callback thunk (e.g., LAB_1402536F0/LAB_1402536F8) with tuple-derived arguments.
- Straight-line flow after tuple creation; minimal/none branching besides null guards.

Key Instructions (evidence):
- tuple = FUN_140FD4D50(&DAT_142513570)
- ctx = *(longlong*)(FUN_1409A4490() + 0x1F0)
- FUN_140250F30(&ctx->+0x88, &LAB_1402536F0, tuple_arg0, tuple_arg1)

Field Layout (inferred from handler offsets):
- Two or more tuple fields are passed directly as callback arguments (e.g., pointer/handle + u32/u8 flags).
- No container lookups or installs; purely a signal/notification message with immediate enqueue semantics.

Wire Structure (first-pass; refine from &DAT_142513570 typecodes)

```cpp
#pragma pack(push, 1)

struct Smsg_0043_Tuple {
    // Arguments forwarded to the queued callback
    void*      arg_ptr;     // representative pointer/handle from tuple
    uint32_t   arg_val;     // representative scalar (id/count/flag)
    // Optional trailing payload depending on schema (blobs or additional scalars)
    uint8_t    payload[];   // if present per schema (0x14/0x15/0x17 etc.)
};

#pragma pack(pop)
```

Notes:
- This packet is a simple “notification enqueue” without per-object state changes; it’s useful as a template for understanding FUN_140250F30-based signaling paths and how tuple fields are mapped into callback parameters.
