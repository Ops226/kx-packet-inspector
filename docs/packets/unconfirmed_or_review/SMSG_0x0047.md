# SMSG 0x0047 — Stateful Update with Cleanup/Gate

Status: Confirmed (code-backed)

Dispatch Path:
- Dispatcher: FUN_14025DA50, case 0x47 (index = opcode − 0x2B)
- Schema: &DAT_142513E60 → passed to FUN_140FD4D50 (typed arg builder)
- Handler code slice (addresses approximate):
  - 0x14025E871..0x14025E94F

Behavior Summary:
- Fetches an object in the table at param_1 + 0x128 using key at (tuple + 0x02). If not found → error.
- If a “loaded/initialized” bit is clear, walks a linked structure and performs cleanup via FUN_140FFC4D0(…+0x48) until a guard bit is observed.
- If *(u32*)(tuple + 0x12) != 0, enqueues/dispatches a notification through a global hub (via FUN_140250F30 with LAB_1402536F8), passing the object and that count value.
- Converts a pointer (tuple+0x10) into a handle RBX (with null-check normalization).
- Calls FUN_140277800(RBX, nullptr) and expects zero; if non-zero, calls a guard check routine.

Key Instructions (evidence):
- tuple = FUN_140FD4D50(&DAT_142513E60)
- obj = FUN_140257E70(param_1 + 0x128, (ulonglong*)(tuple + 0x02)); if 0 → error
- Gate/cleanup:
  • if ((obj[0xC] & 1) == 0) { for (node = obj[0xC]; node != 0; node = *(longlong*)(node + 8 + …)) { FUN_140FFC4D0(node + 0x48); if ((*(u64*)(node + 8 + …) & 1) != 0) break; } }
- If (*(int*)(tuple + 0x12) != 0) → queue with FUN_140250F30(&ctx->+0x88, &LAB_1402536F8, {obj}, {*(u32*)(tuple+0x12)})
- RBX = (tuple + 0x10) normalized; FUN_140277800(RBX, 0); if (ret != 0) → check_icall

Field Layout (inferred from access pattern):
- +0x02: key pointer for lookup in param_1 + 0x128
- +0x10: pointer/handle material (converted to RBX; null normalized)
- +0x12: u32 count/flag; when non-zero triggers a queued notification

Notes:
- This is a guarded state update with optional notification and a strict cleanup path before final operation. It is self-contained with clear guard rails and minimal side effects outside its object scope.
